<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particle System with Hand Tracking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        canvas {
            display: block;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* Webcam Preview */
        #webcam-preview {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
            z-index: 101;
        }

        #webcam-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #webcam-preview .status {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 10px;
            text-transform: uppercase;
        }

        #webcam-preview .status.error {
            color: #f55;
        }

        /* Fullscreen Button */
        #fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 102;
        }

        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        #fullscreen-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        /* Hand Status Indicator */
        #hand-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 101;
        }

        #hand-status .openness {
            color: #0ff;
            font-weight: bold;
        }

        /* Title */
        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: 300;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            letter-spacing: 2px;
            z-index: 101;
        }

        /* Instructions */
        #instructions {
            position: fixed;
            bottom: 180px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            max-width: 200px;
            line-height: 1.5;
            z-index: 101;
        }

        /* Loading Overlay */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading h1 {
            color: white;
            font-weight: 300;
            margin-bottom: 20px;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h1>Loading 3D Particle System...</h1>
        <div class="loader"></div>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <div id="title">3D Particle System</div>

        <!-- Fullscreen Button -->
        <button id="fullscreen-btn" type="button" title="Toggle Fullscreen" aria-label="Toggle Fullscreen">
            <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
            </svg>
        </button>

        <!-- Webcam Preview -->
        <div id="webcam-preview">
            <video id="webcam" playsinline muted></video>
            <div class="status" id="webcam-status">Initializing...</div>
        </div>

        <!-- Hand Status -->
        <div id="hand-status">
            Hand Openness: <span class="openness" id="openness-value">0%</span>
        </div>

        <!-- Instructions -->
        <div id="instructions">
            <strong>Controls:</strong><br>
            • Open/close hand to control particle expansion<br>
            • Use the control panel to change shapes and colors
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

    <!-- lil-gui for UI controls -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/dist/lil-gui.umd.min.js"></script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            particleCount: 10000,
            transitionSpeed: 0.02,
            rotationSpeed: 0.001,
            particleSize: 3,
            color: '#00ffff',
            model: 'heart',
            expansion: 0,
            autoRotate: true
        };

        // Frame timing constants
        const FRAME_DELTA = 1 / 60; // Target 60fps delta time

        // Hand tracking constants
        const FINGER_COUNT = 5;
        const HAND_OPENNESS_SCALE = 3;
        const TWO_HANDS_DISTANCE_SCALE = 2;

        // Heart shape parametric equation coefficients (standard heart curve)
        const HEART_COEFFICIENTS = {
            xAmplitude: 16,
            yBase: 13,
            y2t: 5,
            y3t: 2,
            y4t: 1
        };

        // ============================================
        // SHAPE GENERATORS
        // ============================================
        const ShapeGenerators = {
            // Heart shape using parametric equations
            heart: (i, total) => {
                const t = (i / total) * Math.PI * 2;
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;

                const scale = 50;
                const { xAmplitude, yBase, y2t, y3t, y4t } = HEART_COEFFICIENTS;
                const x = scale * (xAmplitude * Math.pow(Math.sin(t), 3)) * Math.sin(u) * Math.sin(v);
                const y = scale * (yBase * Math.cos(t) - y2t * Math.cos(2*t) - y3t * Math.cos(3*t) - y4t * Math.cos(4*t));
                const z = scale * (xAmplitude * Math.pow(Math.sin(t), 3)) * Math.cos(u) * Math.sin(v);

                return { x, y, z };
            },

            // Flower shape - rose curve in 3D
            flower: (i, total) => {
                const k = 5; // Number of petals
                const theta = (i / total) * Math.PI * 4;
                const phi = Math.random() * Math.PI * 2;
                const r = 80 * Math.cos(k * theta);

                const x = r * Math.cos(theta) * Math.cos(phi);
                const y = r * Math.sin(theta) + (Math.random() - 0.5) * 20;
                const z = r * Math.cos(theta) * Math.sin(phi);
                
                return { x, y, z };
            },

            // Saturn - sphere with rings
            saturn: (i, total) => {
                const isRing = i > total * 0.6;
                
                if (isRing) {
                    // Ring particles
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 80 + Math.random() * 40;
                    return {
                        x: Math.cos(angle) * radius,
                        y: (Math.random() - 0.5) * 5,
                        z: Math.sin(angle) * radius
                    };
                } else {
                    // Sphere particles
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    const radius = 40;
                    
                    return {
                        x: radius * Math.sin(phi) * Math.cos(theta),
                        y: radius * Math.cos(phi),
                        z: radius * Math.sin(phi) * Math.sin(theta)
                    };
                }
            },

            // Buddha - Meditating figure using stacked geometric shapes
            buddha: (i, total) => {
                const section = Math.random();
                let x, y, z;
                
                if (section < 0.25) {
                    // Head (sphere)
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    const r = 20;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = 60 + r * Math.cos(phi);
                    z = r * Math.sin(phi) * Math.sin(theta);
                } else if (section < 0.5) {
                    // Body (ellipsoid)
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    const rx = 35, ry = 40, rz = 25;
                    x = rx * Math.sin(phi) * Math.cos(theta);
                    y = 10 + ry * Math.cos(phi);
                    z = rz * Math.sin(phi) * Math.sin(theta);
                } else if (section < 0.75) {
                    // Crossed legs (torus-like shape at bottom)
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI * 2;
                    const R = 40, r = 15;
                    x = (R + r * Math.cos(phi)) * Math.cos(theta);
                    y = -30 + r * Math.sin(phi) * 0.3;
                    z = (R + r * Math.cos(phi)) * Math.sin(theta) * 0.6;
                } else {
                    // Arms in meditation pose
                    const side = Math.random() > 0.5 ? 1 : -1;
                    const t = Math.random();
                    x = side * (25 + t * 20);
                    y = 10 + Math.sin(t * Math.PI) * 10;
                    z = (Math.random() - 0.5) * 10;
                }
                
                return { x, y, z };
            },

            // Fireworks - exploding particles
            fireworks: (i, total, time = 0) => {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 100;
                
                return {
                    x: radius * Math.sin(phi) * Math.cos(theta),
                    y: radius * Math.cos(phi),
                    z: radius * Math.sin(phi) * Math.sin(theta)
                };
            }
        };

        // ============================================
        // THREE.JS SETUP
        // ============================================
        let scene, camera, renderer, particles;
        let targetPositions = new Float32Array(CONFIG.particleCount * 3);
        let currentPositions = new Float32Array(CONFIG.particleCount * 3);
        let velocities = new Float32Array(CONFIG.particleCount * 3);
        let handOpenness = 0;
        let time = 0;

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 200;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create particles
            createParticles();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Start animation
            animate();
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            
            // Initialize positions
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const pos = ShapeGenerators[CONFIG.model](i, CONFIG.particleCount);
                currentPositions[i * 3] = pos.x;
                currentPositions[i * 3 + 1] = pos.y;
                currentPositions[i * 3 + 2] = pos.z;
                
                targetPositions[i * 3] = pos.x;
                targetPositions[i * 3 + 1] = pos.y;
                targetPositions[i * 3 + 2] = pos.z;
                
                velocities[i * 3] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

            // Material
            const material = new THREE.PointsMaterial({
                color: CONFIG.color,
                size: CONFIG.particleSize,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateShape(shapeName) {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const pos = ShapeGenerators[shapeName](i, CONFIG.particleCount);
                targetPositions[i * 3] = pos.x;
                targetPositions[i * 3 + 1] = pos.y;
                targetPositions[i * 3 + 2] = pos.z;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            time += FRAME_DELTA;

            const positionAttribute = particles.geometry.attributes.position;
            const positions = positionAttribute.array;
            
            // Calculate expansion based on hand openness
            const expansionFactor = 1 + handOpenness * 2;
            const particleScale = 1 + handOpenness * 0.5;
            
            // Special handling for fireworks mode
            if (CONFIG.model === 'fireworks') {
                const cycleTime = (time * 0.5) % 3;
                const explodePhase = Math.min(cycleTime / 1.5, 1);
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    
                    if (cycleTime < 0.1) {
                        // Reset to center
                        positions[i3] = (Math.random() - 0.5) * 5;
                        positions[i3 + 1] = (Math.random() - 0.5) * 5;
                        positions[i3 + 2] = (Math.random() - 0.5) * 5;
                    } else {
                        // Explode outward
                        positions[i3] += velocities[i3] * explodePhase * 2 * expansionFactor;
                        positions[i3 + 1] += velocities[i3 + 1] * explodePhase * 2 * expansionFactor;
                        positions[i3 + 2] += velocities[i3 + 2] * explodePhase * 2 * expansionFactor;
                    }
                }
            } else {
                // Normal morphing for other shapes
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Smooth interpolation to target
                    positions[i3] += (targetPositions[i3] * expansionFactor - positions[i3]) * CONFIG.transitionSpeed;
                    positions[i3 + 1] += (targetPositions[i3 + 1] * expansionFactor - positions[i3 + 1]) * CONFIG.transitionSpeed;
                    positions[i3 + 2] += (targetPositions[i3 + 2] * expansionFactor - positions[i3 + 2]) * CONFIG.transitionSpeed;
                }
            }
            
            positionAttribute.needsUpdate = true;
            
            // Update particle size based on hand openness
            particles.material.size = CONFIG.particleSize * particleScale;
            
            // Auto-rotate
            if (CONFIG.autoRotate) {
                particles.rotation.y += CONFIG.rotationSpeed;
                particles.rotation.x = Math.sin(time * 0.2) * 0.1;
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // MEDIAPIPE HAND TRACKING
        // ============================================
        let hands, cameraUtils;

        async function initHandTracking() {
            const videoElement = document.getElementById('webcam');
            const statusElement = document.getElementById('webcam-status');
            
            try {
                // Initialize MediaPipe Hands
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onHandResults);
                
                // Initialize camera
                cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480
                });
                
                await cameraUtils.start();
                statusElement.textContent = 'Tracking';
                statusElement.classList.remove('error');
                
            } catch (error) {
                console.error('Hand tracking error:', error);
                statusElement.textContent = 'Error: ' + error.message;
                statusElement.classList.add('error');
            }
        }

        function onHandResults(results) {
            const opennessElement = document.getElementById('openness-value');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Calculate hand openness based on finger distances
                const landmarks = results.multiHandLandmarks[0];

                // Calculate distance between fingertips and palm
                const palmBase = landmarks[0];
                const fingertips = [landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]];

                let totalDistance = 0;
                fingertips.forEach(tip => {
                    const dx = tip.x - palmBase.x;
                    const dy = tip.y - palmBase.y;
                    const dz = tip.z - palmBase.z;
                    totalDistance += Math.sqrt(dx*dx + dy*dy + dz*dz);
                });

                // Normalize openness to 0-1 range
                const avgDistance = totalDistance / FINGER_COUNT;
                handOpenness = Math.min(Math.max(avgDistance * HAND_OPENNESS_SCALE, 0), 1);

                // If two hands detected, use distance between them
                if (results.multiHandLandmarks.length > 1) {
                    const hand1 = results.multiHandLandmarks[0][0];
                    const hand2 = results.multiHandLandmarks[1][0];
                    const dx = hand1.x - hand2.x;
                    const dy = hand1.y - hand2.y;
                    const handDistance = Math.sqrt(dx*dx + dy*dy);
                    handOpenness = Math.min(handDistance * TWO_HANDS_DISTANCE_SCALE, 1);
                }

                opennessElement.textContent = Math.round(handOpenness * 100) + '%';
            } else {
                // No hands detected - gradually return to default
                handOpenness *= 0.95;
                opennessElement.textContent = Math.round(handOpenness * 100) + '%';
            }
        }

        // ============================================
        // GUI CONTROLS
        // ============================================
        function initGUI() {
            const gui = new lil.GUI();
            gui.title('Particle Controls');
            
            // Model selector
            gui.add(CONFIG, 'model', ['heart', 'flower', 'saturn', 'buddha', 'fireworks'])
                .name('Shape')
                .onChange((value) => {
                    updateShape(value);
                });
            
            // Color picker
            gui.addColor(CONFIG, 'color')
                .name('Color')
                .onChange((value) => {
                    particles.material.color.set(value);
                });
            
            // Additional controls
            gui.add(CONFIG, 'particleSize', 1, 10)
                .name('Particle Size')
                .onChange((value) => {
                    particles.material.size = value;
                });
            
            gui.add(CONFIG, 'transitionSpeed', 0.01, 0.1)
                .name('Morph Speed');
            
            gui.add(CONFIG, 'rotationSpeed', 0, 0.01)
                .name('Rotation Speed');
            
            gui.add(CONFIG, 'autoRotate')
                .name('Auto Rotate');
        }

        // ============================================
        // FULLSCREEN TOGGLE
        // ============================================
        function initFullscreen() {
            const btn = document.getElementById('fullscreen-btn');
            
            btn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Fullscreen error:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            });
            
            // Update button icon based on fullscreen state
            document.addEventListener('fullscreenchange', () => {
                const svg = btn.querySelector('svg');
                if (document.fullscreenElement) {
                    svg.innerHTML = '<path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>';
                } else {
                    svg.innerHTML = '<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>';
                }
            });
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            // Initialize Three.js
            initThree();
            
            // Initialize GUI
            initGUI();
            
            // Initialize fullscreen toggle
            initFullscreen();
            
            // Initialize hand tracking
            await initHandTracking();
            
            // Hide loading screen
            document.getElementById('loading').classList.add('hidden');
        }

        // Start the application
        init().catch(error => {
            console.error('Initialization error:', error);
            document.getElementById('loading').innerHTML = `
                <h1>Error Loading Application</h1>
                <p style="color: #f55; margin-top: 20px;">${error.message}</p>
            `;
        });
    </script>
</body>
</html>
